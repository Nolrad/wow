<!doctype html>
<html lang="fr">
<head>
  <meta charset="utf-8" />
  <title>Loot Tracker — Import / Historique</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />

  <!-- CSS global -->
  <link rel="stylesheet" href="../assets/css/site.css" />
  <!-- CSS page -->
  <link rel="stylesheet" href="../assets/css/pages/loot_tracker.css" />
</head>

<body>
  <!-- Navbar injectée par ../assets/js/nav.js -->

  <header class="page-header">
    <h1>Loot Tracker</h1>
    <p>Importe l’export JSON de l’addon, stocke localement par personnage, et consulte l’historique des loots.</p>
  </header>

  <main class="container">
    <section class="card">
      <h2>Importer un export</h2>

      <div class="lt-grid">
        <div class="lt-block">
          <h3>Importer un fichier JSON</h3>
          <input id="fileInput" class="lt-file" type="file" accept=".json,application/json" />
          <div class="lt-row">
            <button id="btnImportFile" class="btn btn-primary" type="button">Importer le fichier</button>
            <button id="btnClearPaste" class="btn btn-secondary" type="button">Vider la zone texte</button>
          </div>
          <p class="hint">
            Astuce : tu peux aussi utiliser <strong>/rlt export</strong>, copier le JSON, puis coller ci-dessous.
          </p>
        </div>

        <div class="lt-block">
          <h3>Copier / Coller JSON</h3>
          <textarea id="pasteArea" class="lt-textarea" placeholder="Colle ici ton export JSON complet..."></textarea>
          <div class="lt-row">
            <button id="btnImportPaste" class="btn btn-primary" type="button">Importer le JSON collé</button>
          </div>
          <p class="hint">
            Le stockage est <strong>local au navigateur</strong> (pas dans le dossier /json automatiquement).
          </p>
        </div>
      </div>

      <div class="lt-row lt-row-wrap">
        <label class="lt-check">
          <input id="chkMerge" type="checkbox" checked />
          <span>Fusionner avec l’historique existant du perso (recommandé)</span>
        </label>

        <label class="lt-check">
          <input id="chkFilterMinQuality" type="checkbox" checked />
          <span>Respecter <code>min_quality</code> lors de l’affichage</span>
        </label>
      </div>

      <div id="importStatus" class="lt-status" aria-live="polite"></div>
    </section>

    <section class="card">
      <h2>Consulter l’historique</h2>

      <div class="lt-row lt-row-wrap">
        <label class="lt-label">
          Personnage
          <select id="characterSelect" class="lt-select"></select>
        </label>

        <label class="lt-label">
          Filtre instance
          <input id="instanceFilter" class="lt-input" type="text" placeholder="ex: Karazhan, Gouffre..." />
        </label>

        <label class="lt-label">
          Filtre item
          <input id="itemFilter" class="lt-input" type="text" placeholder="ex: Cape, Épée..." />
        </label>

        <button id="btnRefresh" class="btn btn-secondary" type="button">Rafraîchir</button>
      </div>

      <div class="lt-row lt-row-wrap">
        <button id="btnExportCharacter" class="btn btn-primary" type="button">Exporter ce perso (download)</button>
        <button id="btnDeleteCharacter" class="btn btn-danger" type="button">Supprimer ce perso (local)</button>
        <button id="btnDeleteAll" class="btn btn-danger" type="button">Tout supprimer (local)</button>
      </div>

      <p class="hint">
        Pour créer un dossier <code>/json/</code> dans ton repo : exporte ici, puis place le fichier téléchargé dans <code>json/</code> et commit.
      </p>

      <div id="summary" class="lt-summary"></div>

      <div class="lt-tableWrap" role="region" aria-label="Table des loots" tabindex="0">
        <table class="lt-table">
          <thead>
            <tr>
              <th>Date</th>
              <th>Instance</th>
              <th>Boss</th>
              <th>Joueur</th>
              <th>Item</th>
              <th>Qualité</th>
              <th>Rand</th>
            </tr>
          </thead>
          <tbody id="lootTbody"></tbody>
        </table>
      </div>
    </section>

    <section class="card">
      <h2>À propos du dossier /json</h2>
      <ul>
        <li>Un site statique (GitHub Pages) ne permet pas d’écrire dans <code>/json/</code> depuis le navigateur.</li>
        <li>Le workflow simple : <strong>import → stockage local → export download → tu copies dans /json → commit</strong>.</li>
        <li>Si un jour tu veux une écriture automatique côté serveur, il faudra un backend (API).</li>
      </ul>
    </section>

    <div class="footer">
      Loot Tracker — import JSON addon → stockage local → export “prêt à déposer”
    </div>
  </main>

  <script src="../assets/js/nav.js"></script>
  <script>
    // ==========================
    // Storage format (local)
    // ==========================
    // localStorage keys:
    //   LT_INDEX = JSON array of character IDs
    //   LT_CHAR_<id> = JSON of { id, realm, player, history: [exports...] }
    //
    // id = realm + "|" + player (unique enough for your use)

    const LT_INDEX = "LT_INDEX_V1";
    const LT_PREFIX = "LT_CHAR_V1_";

    function $(id) { return document.getElementById(id); }

    function safeJsonParse(text) {
      try { return { ok: true, value: JSON.parse(text) }; }
      catch (e) { return { ok: false, error: String(e) }; }
    }

    function normalizeExport(raw) {
      // Basic shape validation + normalize minimal
      if (!raw || typeof raw !== "object") throw new Error("JSON invalide: pas un objet");
      if (!raw.player || !raw.realm) throw new Error("JSON invalide: champs 'player' ou 'realm' manquants");
      raw.runs = Array.isArray(raw.runs) ? raw.runs : [];
      return raw;
    }

    function charId(realm, player) {
      return `${String(realm)}|${String(player)}`;
    }

    function loadIndex() {
      const raw = localStorage.getItem(LT_INDEX);
      if (!raw) return [];
      const p = safeJsonParse(raw);
      return p.ok && Array.isArray(p.value) ? p.value : [];
    }

    function saveIndex(ids) {
      localStorage.setItem(LT_INDEX, JSON.stringify(ids));
    }

    function loadChar(id) {
      const raw = localStorage.getItem(LT_PREFIX + id);
      if (!raw) return null;
      const p = safeJsonParse(raw);
      return p.ok ? p.value : null;
    }

    function saveChar(obj) {
      localStorage.setItem(LT_PREFIX + obj.id, JSON.stringify(obj));
    }

    function addCharToIndex(id) {
      const ids = loadIndex();
      if (!ids.includes(id)) {
        ids.push(id);
        ids.sort((a,b) => a.localeCompare(b));
        saveIndex(ids);
      }
    }

    function setStatus(msg, kind="info") {
      const el = $("importStatus");
      el.className = "lt-status " + (kind ? "is-" + kind : "");
      el.textContent = msg;
    }

    function extractLootRows(exportObj, respectMinQuality=true) {
      const rows = [];
      const minQ = Number(exportObj.min_quality ?? 0);

      for (const run of (exportObj.runs || [])) {
        const instance = (run.instance_override && run.instance_override.trim()) ? run.instance_override : (run.instance || "");
        const started = run.started_at_human || exportObj.date || "";

        for (const boss of (run.bosses || [])) {
          const bossName = boss.name || "";
          for (const loot of (boss.loots || [])) {
            const q = Number(loot.quality ?? 0);
            if (respectMinQuality && q < minQ) continue;

            rows.push({
              date: loot.time_human || started,
              instance,
              boss: bossName,
              player: loot.player || exportObj.player,
              item: loot.item || "",
              quality: q,
              quality_name: loot.quality_name || "",
              rand: loot.rand ?? null,
            });
          }
        }
      }
      return rows;
    }

    function qualityLabel(q) {
      // Keep consistent with addon
      const map = {
        0: "Médiocre",
        1: "Commun",
        2: "Inhabituel",
        3: "Rare",
        4: "Épique",
        5: "Légendaire",
      };
      return map[q] ?? String(q);
    }

    function qualityClass(q) {
      return "q" + String(q);
    }

    function renderCharacterSelect() {
      const sel = $("characterSelect");
      const ids = loadIndex();
      sel.innerHTML = "";
      if (ids.length === 0) {
        const opt = document.createElement("option");
        opt.value = "";
        opt.textContent = "Aucun perso (importe un JSON)";
        sel.appendChild(opt);
        sel.disabled = true;
        return;
      }
      sel.disabled = false;

      for (const id of ids) {
        const c = loadChar(id);
        const opt = document.createElement("option");
        opt.value = id;
        opt.textContent = c ? `${c.player} — ${c.realm}` : id;
        sel.appendChild(opt);
      }
    }

    function getSelectedChar() {
      const id = $("characterSelect").value;
      if (!id) return null;
      return loadChar(id);
    }

    function flattenHistory(charObj) {
      // history = array of exports; merge all rows
      const respect = $("chkFilterMinQuality").checked;
      let rows = [];
      for (const exp of (charObj.history || [])) {
        rows = rows.concat(extractLootRows(exp, respect));
      }
      return rows;
    }

    function applyFilters(rows) {
      const inst = $("instanceFilter").value.trim().toLowerCase();
      const item = $("itemFilter").value.trim().toLowerCase();

      return rows.filter(r => {
        const okInst = !inst || (r.instance || "").toLowerCase().includes(inst);
        const okItem = !item || (r.item || "").toLowerCase().includes(item);
        return okInst && okItem;
      });
    }

    function renderTable() {
      const tbody = $("lootTbody");
      tbody.innerHTML = "";

      const c = getSelectedChar();
      if (!c) {
        $("summary").textContent = "Aucun perso sélectionné.";
        return;
      }

      let rows = flattenHistory(c);
      rows = applyFilters(rows);

      // sort newest first (best effort)
      rows.sort((a,b) => String(b.date).localeCompare(String(a.date)));

      // summary
      const total = rows.length;
      const byQ = {0:0,1:0,2:0,3:0,4:0,5:0};
      for (const r of rows) byQ[r.quality] = (byQ[r.quality] || 0) + 1;

      $("summary").innerHTML = `
        <div class="lt-summaryGrid">
          <div class="lt-sumCard"><div class="lt-sumNum">${total}</div><div class="lt-sumLabel">Loots (filtrés)</div></div>
          <div class="lt-sumCard ${qualityClass(1)}"><div class="lt-sumNum">${byQ[1]||0}</div><div class="lt-sumLabel">Commun</div></div>
          <div class="lt-sumCard ${qualityClass(2)}"><div class="lt-sumNum">${byQ[2]||0}</div><div class="lt-sumLabel">Inhabituel</div></div>
          <div class="lt-sumCard ${qualityClass(3)}"><div class="lt-sumNum">${byQ[3]||0}</div><div class="lt-sumLabel">Rare</div></div>
          <div class="lt-sumCard ${qualityClass(4)}"><div class="lt-sumNum">${byQ[4]||0}</div><div class="lt-sumLabel">Épique</div></div>
          <div class="lt-sumCard ${qualityClass(5)}"><div class="lt-sumNum">${byQ[5]||0}</div><div class="lt-sumLabel">Légendaire</div></div>
        </div>
      `;

      if (rows.length === 0) {
        const tr = document.createElement("tr");
        tr.innerHTML = `<td colspan="7" class="lt-empty">Aucun loot (ou tout filtré).</td>`;
        tbody.appendChild(tr);
        return;
      }

      for (const r of rows) {
        const tr = document.createElement("tr");
        const randStr = (r.rand === null || r.rand === undefined) ? "—" : String(r.rand);
        const qName = r.quality_name || qualityLabel(r.quality);
        tr.innerHTML = `
          <td>${escapeHtml(r.date || "")}</td>
          <td>${escapeHtml(r.instance || "")}</td>
          <td>${escapeHtml(r.boss || "")}</td>
          <td>${escapeHtml(r.player || "")}</td>
          <td class="lt-item">${escapeHtml(r.item || "")}</td>
          <td class="lt-quality ${qualityClass(r.quality)}">${escapeHtml(qName)}</td>
          <td>${escapeHtml(randStr)}</td>
        `;
        tbody.appendChild(tr);
      }
    }

    function escapeHtml(s) {
      return String(s).replace(/[&<>"']/g, c => ({
        "&":"&amp;","<":"&lt;",">":"&gt;",'"':"&quot;","'":"&#39;"
      }[c]));
    }

    function importExportObject(exportObj, merge=true) {
      exportObj = normalizeExport(exportObj);

      const id = charId(exportObj.realm, exportObj.player);
      const existing = loadChar(id);

      const record = existing && merge ? existing : {
        id,
        realm: exportObj.realm,
        player: exportObj.player,
        created_at: new Date().toISOString(),
        history: []
      };

      // Avoid duplicates (simple heuristic)
      const sig = `${exportObj.date}|${exportObj.started_at}|${(exportObj.runs||[]).length}`;
      record._seen = record._seen || {};
      if (!record._seen[sig]) {
        record.history.push(exportObj);
        record._seen[sig] = true;
      }

      record.updated_at = new Date().toISOString();

      saveChar(record);
      addCharToIndex(id);
      return record;
    }

    function downloadJson(filename, obj) {
      const blob = new Blob([JSON.stringify(obj, null, 2)], { type: "application/json;charset=utf-8" });
      const url = URL.createObjectURL(blob);
      const a = document.createElement("a");
      a.href = url;
      a.download = filename;
      document.body.appendChild(a);
      a.click();
      document.body.removeChild(a);
      URL.revokeObjectURL(url);
    }

    function exportSelectedCharacter() {
      const c = getSelectedChar();
      if (!c) return;

      // Export "perso-historique" (tout ce que tu as importé localement)
      const payload = {
        schema: 1,
        exported_at: new Date().toISOString(),
        realm: c.realm,
        player: c.player,
        history: c.history || []
      };

      // file name: player_realm_loot_history.json
      const safePlayer = String(c.player).replace(/[^a-z0-9_-]/gi, "_");
      const safeRealm = String(c.realm).replace(/[^a-z0-9_-]/gi, "_");
      downloadJson(`${safePlayer}_${safeRealm}_loot_history.json`, payload);
    }

    // ==========================
    // Wire UI
    // ==========================
    document.addEventListener("DOMContentLoaded", () => {
      renderCharacterSelect();
      renderTable();

      $("btnClearPaste").addEventListener("click", () => {
        $("pasteArea").value = "";
        setStatus("Zone texte vidée.", "info");
      });

      $("btnImportFile").addEventListener("click", async () => {
        const file = $("fileInput").files && $("fileInput").files[0];
        if (!file) {
          setStatus("Sélectionne un fichier JSON.", "warn");
          return;
        }
        const text = await file.text();
        const parsed = safeJsonParse(text);
        if (!parsed.ok) {
          setStatus("JSON invalide: " + parsed.error, "error");
          return;
        }
        try {
          const merge = $("chkMerge").checked;
          const rec = importExportObject(parsed.value, merge);
          setStatus(`Import OK: ${rec.player} — ${rec.realm} (historique: ${rec.history.length})`, "ok");
          renderCharacterSelect();
          $("characterSelect").value = rec.id;
          renderTable();
        } catch (e) {
          setStatus("Erreur import: " + String(e), "error");
        }
      });

      $("btnImportPaste").addEventListener("click", () => {
        const text = $("pasteArea").value.trim();
        if (!text) {
          setStatus("Colle un JSON dans la zone texte.", "warn");
          return;
        }
        const parsed = safeJsonParse(text);
        if (!parsed.ok) {
          setStatus("JSON invalide: " + parsed.error, "error");
          return;
        }
        try {
          const merge = $("chkMerge").checked;
          const rec = importExportObject(parsed.value, merge);
          setStatus(`Import OK: ${rec.player} — ${rec.realm} (historique: ${rec.history.length})`, "ok");
          renderCharacterSelect();
          $("characterSelect").value = rec.id;
          renderTable();
        } catch (e) {
          setStatus("Erreur import: " + String(e), "error");
        }
      });

      $("btnRefresh").addEventListener("click", () => renderTable());
      $("characterSelect").addEventListener("change", () => renderTable());
      $("instanceFilter").addEventListener("input", () => renderTable());
      $("itemFilter").addEventListener("input", () => renderTable());
      $("chkFilterMinQuality").addEventListener("change", () => renderTable());

      $("btnExportCharacter").addEventListener("click", () => exportSelectedCharacter());

      $("btnDeleteCharacter").addEventListener("click", () => {
        const c = getSelectedChar();
        if (!c) return;
        if (!confirm(`Supprimer localement ${c.player} — ${c.realm} ?`)) return;

        localStorage.removeItem(LT_PREFIX + c.id);
        const ids = loadIndex().filter(x => x !== c.id);
        saveIndex(ids);

        setStatus(`Supprimé: ${c.player} — ${c.realm}`, "info");
        renderCharacterSelect();
        renderTable();
      });

      $("btnDeleteAll").addEventListener("click", () => {
        if (!confirm("Tout supprimer localement ?")) return;
        const ids = loadIndex();
        for (const id of ids) localStorage.removeItem(LT_PREFIX + id);
        localStorage.removeItem(LT_INDEX);
        setStatus("Tout supprimé localement.", "info");
        renderCharacterSelect();
        renderTable();
      });
    });
  </script>
</body>
</html>

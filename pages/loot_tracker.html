<!doctype html>
<html lang="fr">
<head>
  <meta charset="utf-8" />
  <title>Loot Tracker — Import / Historique</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />

  <!-- CSS global -->
  <link rel="stylesheet" href="../assets/css/site.css" />
  <!-- CSS page -->
  <link rel="stylesheet" href="../assets/css/pages/loot_tracker.css" />
</head>

<body>
  <!-- Navbar injectée par ../assets/js/nav.js -->

  <header class="page-header">
    <h1>Loot Tracker</h1>
    <p>Importe l’export JSON de l’addon (format <code>events[]</code>), stocke localement par “recorder”, et consulte l’historique des loots.</p>
  </header>

  <main class="container">
    <section class="card">
      <h2>Importer un export</h2>

      <div class="lt-grid">
        <div class="lt-block">
          <h3>Importer un fichier JSON</h3>
          <input id="fileInput" class="lt-file" type="file" accept=".json,application/json" />
          <div class="lt-row">
            <button id="btnImportFile" class="btn btn-primary" type="button">Importer le fichier</button>
            <button id="btnClearPaste" class="btn btn-secondary" type="button">Vider la zone texte</button>
          </div>
          <p class="hint">
            Astuce : <strong>/rlt ui</strong> → Exporter JSON → copier/coller ci-dessous, ou enregistre le fichier et importe-le.
          </p>
        </div>

        <div class="lt-block">
          <h3>Copier / Coller JSON</h3>
          <textarea id="pasteArea" class="lt-textarea" placeholder="Colle ici ton export JSON complet..."></textarea>
          <div class="lt-row lt-row-wrap">
            <button id="btnImportPaste" class="btn btn-primary" type="button">Importer le JSON collé</button>
            <button id="btnCopyPaste" class="btn btn-secondary" type="button">Copier la zone</button>
          </div>
          <p class="hint">
            Le stockage est <strong>local au navigateur</strong>. Pour alimenter <code>/json/</code> (dans ton repo) :
            exporte (download) puis dépose le fichier dans <code>/json/</code> et commit.
          </p>
        </div>
      </div>

      <div class="lt-row lt-row-wrap">
        <label class="lt-check">
          <input id="chkMerge" type="checkbox" checked />
          <span>Fusionner avec l’historique existant du recorder (recommandé)</span>
        </label>

        <label class="lt-check">
          <input id="chkFilterMinQuality" type="checkbox" checked />
          <span>Respecter <code>min_quality</code> lors de l’affichage (si présent)</span>
        </label>
      </div>

      <div id="importStatus" class="lt-status" aria-live="polite"></div>
    </section>

    <section class="card">
      <h2>Consulter l’historique</h2>

      <div class="lt-row lt-row-wrap">
        <label class="lt-label">
          Recorder (celui qui enregistre)
          <select id="characterSelect" class="lt-select"></select>
        </label>

        <label class="lt-label">
          Filtre instance
          <input id="instanceFilter" class="lt-input" type="text" placeholder="ex: Karazhan, Monastère..." />
        </label>

        <label class="lt-label">
          Filtre item
          <input id="itemFilter" class="lt-input" type="text" placeholder="ex: Chapeau, Égide..." />
        </label>

        <button id="btnRefresh" class="btn btn-secondary" type="button">Rafraîchir</button>
      </div>

      <div class="lt-row lt-row-wrap">
        <button id="btnExportCharacter" class="btn btn-primary" type="button">Exporter ce recorder (download)</button>
        <button id="btnCopyCharacter" class="btn btn-secondary" type="button">Copier l’export (clipboard)</button>
        <button id="btnDeleteCharacter" class="btn btn-danger" type="button">Supprimer ce recorder (local)</button>
        <button id="btnDeleteAll" class="btn btn-danger" type="button">Tout supprimer (local)</button>
      </div>

      <p class="hint">
        Tri : clique sur un en-tête (Date / Instance / Boss / Joueur / Item / Qualité / Rand). Re-clique pour inverser.
        <br />
        Dossier conseillé dans le repo : <code>/json/</code> à la racine.
      </p>

      <div id="summary" class="lt-summary"></div>

      <div class="lt-tableWrap" role="region" aria-label="Table des loots" tabindex="0">
        <table class="lt-table">
          <thead>
            <tr>
              <th data-sort="date">Date</th>
              <th data-sort="instance">Instance</th>
              <th data-sort="boss">Boss</th>
              <th data-sort="player">Joueur</th>
              <th data-sort="item">Item</th>
              <th data-sort="quality">Qualité</th>
              <th data-sort="rand">Rand</th>
            </tr>
          </thead>
          <tbody id="lootTbody"></tbody>
        </table>
      </div>
    </section>

    <section class="card">
      <h2>À propos du dossier /json</h2>
      <ul>
        <li>Sur un site statique (GitHub Pages), on ne peut pas écrire automatiquement dans <code>/json/</code> depuis le navigateur.</li>
        <li>Workflow : <strong>import → stockage local → export (download) → tu copies dans /json → commit</strong>.</li>
      </ul>
    </section>

    <div class="footer">
      Loot Tracker — import JSON addon → stockage local → tri → export “prêt à déposer”
    </div>
  </main>

  <script src="../assets/js/nav.js"></script>
  <script>
    // =========================================================
    // Loot Tracker (localStorage) - supporte:
    //  - nouveau format: { schema, exported_at, realm, recorder, events:[...] }
    //  - ancien format (fallback): { realm, player, runs:[{bosses:[{loots:[]}]}] }
    // =========================================================

    const LT_INDEX = "LT_INDEX_V1";
    const LT_PREFIX = "LT_CHAR_V1_";

    // Etat de tri (clic sur entêtes)
    let SORT = { key: "date", dir: "desc" }; // desc = récent d'abord

    function $(id) { return document.getElementById(id); }

    function safeJsonParse(text) {
      try { return { ok: true, value: JSON.parse(text) }; }
      catch (e) { return { ok: false, error: String(e) }; }
    }

    function charId(realm, player) {
      return `${String(realm)}|${String(player)}`;
    }

    function loadIndex() {
      const raw = localStorage.getItem(LT_INDEX);
      if (!raw) return [];
      const p = safeJsonParse(raw);
      return p.ok && Array.isArray(p.value) ? p.value : [];
    }

    function saveIndex(ids) {
      localStorage.setItem(LT_INDEX, JSON.stringify(ids));
    }

    function loadChar(id) {
      const raw = localStorage.getItem(LT_PREFIX + id);
      if (!raw) return null;
      const p = safeJsonParse(raw);
      return p.ok ? p.value : null;
    }

    function saveChar(obj) {
      localStorage.setItem(LT_PREFIX + obj.id, JSON.stringify(obj));
    }

    function addCharToIndex(id) {
      const ids = loadIndex();
      if (!ids.includes(id)) {
        ids.push(id);
        ids.sort((a,b) => a.localeCompare(b));
        saveIndex(ids);
      }
    }

    function setStatus(msg, kind="info") {
      const el = $("importStatus");
      el.className = "lt-status " + (kind ? "is-" + kind : "");
      el.textContent = msg;
    }

    function escapeHtml(s) {
      return String(s).replace(/[&<>"']/g, c => ({
        "&":"&amp;","<":"&lt;",">":"&gt;",'"':"&quot;","'":"&#39;"
      }[c]));
    }

    function qualityLabel(q) {
      const map = {
        0: "Médiocre",
        1: "Commun",
        2: "Inhabituel",
        3: "Rare",
        4: "Épique",
        5: "Légendaire",
      };
      return map[q] ?? String(q);
    }

    function qualityClass(q) {
      return "q" + String(q);
    }

    // --------------------------
    // Normalisation
    // --------------------------
    function normalizeExport(raw) {
      if (!raw || typeof raw !== "object") throw new Error("JSON invalide: pas un objet");
      if (!raw.realm) throw new Error("JSON invalide: champ 'realm' manquant");

      // Nouveau format: schema + recorder + events[]
      if (Array.isArray(raw.events)) {
        raw.schema = Number(raw.schema ?? 1);
        raw.recorder = raw.recorder || "Unknown";
        raw.exported_at = raw.exported_at || new Date().toISOString();
        raw.events = Array.isArray(raw.events) ? raw.events : [];
        raw.min_quality = Number(raw.min_quality ?? 0);
        return raw;
      }

      // Ancien format (fallback)
      if (!raw.player) throw new Error("JSON invalide: champ 'player' manquant (ancien format)");
      raw.runs = Array.isArray(raw.runs) ? raw.runs : [];
      raw.min_quality = Number(raw.min_quality ?? 0);
      return raw;
    }

    // --------------------------
    // Extraction rows
    // --------------------------
    function extractLootRows(exportObj, respectMinQuality = true) {
      const rows = [];

      // Nouveau format: events[]
      if (Array.isArray(exportObj.events)) {
        const minQ = Number(exportObj.min_quality ?? 0);

        for (const e of exportObj.events) {
          const q = Number(e.quality ?? 0);
          if (respectMinQuality && q < minQ) continue;

          rows.push({
            time: e.time ?? null,
            date: e.time_human || "",
            instance: e.instance || "",
            boss: e.boss || "",
            player: e.winner || "",
            item: e.item || "",
            quality: q,
            quality_name: e.quality_name || "",
            rand: e.winning_roll ?? null,
          });
        }

        return rows;
      }

      // Ancien format: runs/bosses/loots
      const minQ = Number(exportObj.min_quality ?? 0);

      for (const run of (exportObj.runs || [])) {
        const instance =
          (run.instance_override && run.instance_override.trim())
            ? run.instance_override
            : (run.instance || "");

        const started = run.started_at_human || exportObj.started_at || exportObj.date || "";

        for (const boss of (run.bosses || [])) {
          const bossName = boss.name || "";

          for (const loot of (boss.loots || [])) {
            const q = Number(loot.quality ?? 0);
            if (respectMinQuality && q < minQ) continue;

            rows.push({
              time: loot.time ?? null,
              date: loot.time_human || started,
              instance,
              boss: bossName,
              player: loot.player || exportObj.player,
              item: loot.item || "",
              quality: q,
              quality_name: loot.quality_name || "",
              rand: loot.rand ?? null,
            });
          }
        }
      }

      return rows;
    }

    // --------------------------
    // Tri
    // --------------------------
    function getSortValue(row, key) {
      switch (key) {
        case "quality": return Number(row.quality ?? -1);
        case "rand": return (row.rand === null || row.rand === undefined) ? -1 : Number(row.rand);
        case "date":
          return (row.time !== null && row.time !== undefined) ? Number(row.time) : String(row.date ?? "");
        default:
          return String(row[key] ?? "").toLowerCase();
      }
    }

    function sortRows(rows) {
      const { key, dir } = SORT;
      const mul = dir === "asc" ? 1 : -1;

      rows.sort((a, b) => {
        const va = getSortValue(a, key);
        const vb = getSortValue(b, key);

        if (typeof va === "number" && typeof vb === "number") {
          return (va - vb) * mul;
        }
        return String(va).localeCompare(String(vb), "fr", { sensitivity: "base" }) * mul;
      });

      return rows;
    }

    // --------------------------
    // UI Helpers
    // --------------------------
    function renderCharacterSelect() {
      const sel = $("characterSelect");
      const ids = loadIndex();
      sel.innerHTML = "";

      if (ids.length === 0) {
        const opt = document.createElement("option");
        opt.value = "";
        opt.textContent = "Aucun recorder (importe un JSON)";
        sel.appendChild(opt);
        sel.disabled = true;
        return;
      }

      sel.disabled = false;

      for (const id of ids) {
        const c = loadChar(id);
        const opt = document.createElement("option");
        opt.value = id;
        opt.textContent = c ? `${c.player} — ${c.realm}` : id;
        sel.appendChild(opt);
      }
    }

    function getSelectedChar() {
      const id = $("characterSelect").value;
      if (!id) return null;
      return loadChar(id);
    }

    function flattenHistory(charObj) {
      const respect = $("chkFilterMinQuality").checked;
      let rows = [];
      for (const exp of (charObj.history || [])) {
        rows = rows.concat(extractLootRows(exp, respect));
      }
      return rows;
    }

    function applyFilters(rows) {
      const inst = $("instanceFilter").value.trim().toLowerCase();
      const item = $("itemFilter").value.trim().toLowerCase();

      return rows.filter(r => {
        const okInst = !inst || (r.instance || "").toLowerCase().includes(inst);
        const okItem = !item || (r.item || "").toLowerCase().includes(item);
        return okInst && okItem;
      });
    }

    function renderTable() {
      const tbody = $("lootTbody");
      tbody.innerHTML = "";

      const c = getSelectedChar();
      if (!c) {
        $("summary").textContent = "Aucun recorder sélectionné.";
        return;
      }

      let rows = flattenHistory(c);
      rows = applyFilters(rows);
      sortRows(rows);

      // summary
      const total = rows.length;
      const byQ = {0:0,1:0,2:0,3:0,4:0,5:0};
      for (const r of rows) byQ[r.quality] = (byQ[r.quality] || 0) + 1;

      $("summary").innerHTML = `
        <div class="lt-summaryGrid">
          <div class="lt-sumCard"><div class="lt-sumNum">${total}</div><div class="lt-sumLabel">Loots (filtrés)</div></div>
          <div class="lt-sumCard ${qualityClass(1)}"><div class="lt-sumNum">${byQ[1]||0}</div><div class="lt-sumLabel">Commun</div></div>
          <div class="lt-sumCard ${qualityClass(2)}"><div class="lt-sumNum">${byQ[2]||0}</div><div class="lt-sumLabel">Inhabituel</div></div>
          <div class="lt-sumCard ${qualityClass(3)}"><div class="lt-sumNum">${byQ[3]||0}</div><div class="lt-sumLabel">Rare</div></div>
          <div class="lt-sumCard ${qualityClass(4)}"><div class="lt-sumNum">${byQ[4]||0}</div><div class="lt-sumLabel">Épique</div></div>
          <div class="lt-sumCard ${qualityClass(5)}"><div class="lt-sumNum">${byQ[5]||0}</div><div class="lt-sumLabel">Légendaire</div></div>
        </div>
      `;

      if (rows.length === 0) {
        const tr = document.createElement("tr");
        tr.innerHTML = `<td colspan="7" class="lt-empty">Aucun loot (ou tout filtré).</td>`;
        tbody.appendChild(tr);
        return;
      }

      for (const r of rows) {
        const tr = document.createElement("tr");
        const randStr = (r.rand === null || r.rand === undefined) ? "—" : String(r.rand);
        const qName = r.quality_name || qualityLabel(r.quality);

        tr.innerHTML = `
          <td>${escapeHtml(r.date || "")}</td>
          <td>${escapeHtml(r.instance || "")}</td>
          <td>${escapeHtml(r.boss || "")}</td>
          <td>${escapeHtml(r.player || "")}</td>
          <td class="lt-item">${escapeHtml(r.item || "")}</td>
          <td class="lt-quality ${qualityClass(r.quality)}">${escapeHtml(qName)}</td>
          <td>${escapeHtml(randStr)}</td>
        `;
        tbody.appendChild(tr);
      }
    }

    // --------------------------
    // Import / Merge
    // --------------------------
    function importExportObject(exportObj, merge = true) {
      exportObj = normalizeExport(exportObj);

      // Nouveau format: stocké par recorder
      const recorderName = exportObj.recorder || exportObj.player || "Unknown";
      const id = charId(exportObj.realm, recorderName);

      const existing = loadChar(id);

      const record = existing && merge ? existing : {
        id,
        realm: exportObj.realm,
        player: recorderName, // "player" = recorder, côté UI
        created_at: new Date().toISOString(),
        history: [],
        _seen: {}
      };

      // Anti doublon
      const count = Array.isArray(exportObj.events) ? exportObj.events.length : (exportObj.runs || []).length;
      const sig = `${exportObj.exported_at || exportObj.started_at || exportObj.date || ""}|${count}`;
      record._seen = record._seen || {};

      if (!record._seen[sig]) {
        record.history.push(exportObj);
        record._seen[sig] = true;
      }

      record.updated_at = new Date().toISOString();

      saveChar(record);
      addCharToIndex(id);
      return record;
    }

    // --------------------------
    // Export
    // --------------------------
    function buildRecorderExport(c) {
      return {
        schema: 1,
        exported_at: new Date().toISOString(),
        realm: c.realm,
        recorder: c.player,
        history: c.history || []
      };
    }

    function downloadJson(filename, obj) {
      const blob = new Blob([JSON.stringify(obj, null, 2)], { type: "application/json;charset=utf-8" });
      const url = URL.createObjectURL(blob);
      const a = document.createElement("a");
      a.href = url;
      a.download = filename;
      document.body.appendChild(a);
      a.click();
      document.body.removeChild(a);
      URL.revokeObjectURL(url);
    }

    function exportSelectedRecorderDownload() {
      const c = getSelectedChar();
      if (!c) return;

      const payload = buildRecorderExport(c);
      const safeRecorder = String(c.player).replace(/[^a-z0-9_-]/gi, "_");
      const safeRealm = String(c.realm).replace(/[^a-z0-9_-]/gi, "_");
      downloadJson(`${safeRecorder}_${safeRealm}_loot_history.json`, payload);
    }

    async function exportSelectedRecorderClipboard() {
      const c = getSelectedChar();
      if (!c) return;

      const payload = buildRecorderExport(c);
      const text = JSON.stringify(payload, null, 2);

      try {
        await navigator.clipboard.writeText(text);
        setStatus("Export copié dans le presse-papier.", "ok");
      } catch {
        setStatus("Impossible de copier (permission navigateur). Utilise l’export download.", "warn");
      }
    }

    async function copyPasteArea() {
      const t = $("pasteArea").value || "";
      try {
        await navigator.clipboard.writeText(t);
        setStatus("Zone texte copiée.", "ok");
      } catch {
        setStatus("Impossible de copier (permission navigateur).", "warn");
      }
    }

    // --------------------------
    // Wire UI
    // --------------------------
    document.addEventListener("DOMContentLoaded", () => {
      renderCharacterSelect();
      renderTable();

      // Tri via clic sur en-têtes
      document.querySelectorAll(".lt-table thead th[data-sort]").forEach(th => {
        th.style.cursor = "pointer";
        th.addEventListener("click", () => {
          const key = th.dataset.sort;
          if (SORT.key === key) {
            SORT.dir = (SORT.dir === "asc") ? "desc" : "asc";
          } else {
            SORT.key = key;
            SORT.dir = (key === "date") ? "desc" : "asc";
          }
          renderTable();
        });
      });

      $("btnClearPaste").addEventListener("click", () => {
        $("pasteArea").value = "";
        setStatus("Zone texte vidée.", "info");
      });

      $("btnCopyPaste").addEventListener("click", () => copyPasteArea());

      $("btnImportFile").addEventListener("click", async () => {
        const file = $("fileInput").files && $("fileInput").files[0];
        if (!file) {
          setStatus("Sélectionne un fichier JSON.", "warn");
          return;
        }
        const text = await file.text();
        const parsed = safeJsonParse(text);
        if (!parsed.ok) {
          setStatus("JSON invalide: " + parsed.error, "error");
          return;
        }
        try {
          const merge = $("chkMerge").checked;
          const rec = importExportObject(parsed.value, merge);
          setStatus(`Import OK: ${rec.player} — ${rec.realm} (historique: ${rec.history.length})`, "ok");
          renderCharacterSelect();
          $("characterSelect").value = rec.id;
          renderTable();
        } catch (e) {
          setStatus("Erreur import: " + String(e), "error");
        }
      });

      $("btnImportPaste").addEventListener("click", () => {
        const text = $("pasteArea").value.trim();
        if (!text) {
          setStatus("Colle un JSON dans la zone texte.", "warn");
          return;
        }
        const parsed = safeJsonParse(text);
        if (!parsed.ok) {
          setStatus("JSON invalide: " + parsed.error, "error");
          return;
        }
        try {
          const merge = $("chkMerge").checked;
          const rec = importExportObject(parsed.value, merge);
          setStatus(`Import OK: ${rec.player} — ${rec.realm} (historique: ${rec.history.length})`, "ok");
          renderCharacterSelect();
          $("characterSelect").value = rec.id;
          renderTable();
        } catch (e) {
          setStatus("Erreur import: " + String(e), "error");
        }
      });

      $("btnRefresh").addEventListener("click", () => renderTable());
      $("characterSelect").addEventListener("change", () => renderTable());
      $("instanceFilter").addEventListener("input", () => renderTable());
      $("itemFilter").addEventListener("input", () => renderTable());
      $("chkFilterMinQuality").addEventListener("change", () => renderTable());

      $("btnExportCharacter").addEventListener("click", () => exportSelectedRecorderDownload());
      $("btnCopyCharacter").addEventListener("click", () => exportSelectedRecorderClipboard());

      $("btnDeleteCharacter").addEventListener("click", () => {
        const c = getSelectedChar();
        if (!c) return;
        if (!confirm(`Supprimer localement ${c.player} — ${c.realm} ?`)) return;

        localStorage.removeItem(LT_PREFIX + c.id);
        const ids = loadIndex().filter(x => x !== c.id);
        saveIndex(ids);

        setStatus(`Supprimé: ${c.player} — ${c.realm}`, "info");
        renderCharacterSelect();
        renderTable();
      });

      $("btnDeleteAll").addEventListener("click", () => {
        if (!confirm("Tout supprimer localement ?")) return;
        const ids = loadIndex();
        for (const id of ids) localStorage.removeItem(LT_PREFIX + id);
        localStorage.removeItem(LT_INDEX);
        setStatus("Tout supprimé localement.", "info");
        renderCharacterSelect();
        renderTable();
      });
    });
  </script>
</body>
</html>
